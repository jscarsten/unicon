procedure printnode(n)
	write("node type: " || type(n))
	write("node label: " || n.label)
end


procedure grab_cases(caselist)
	static casevalues, basetype
	initial {
		casevalues := [] 
		basetype := caselist.children[3].children[1].tok # get the type of 1 token
		basetype = 258 | basetype = 260 | fail # assert t is an integer or string
	}

	if caselist.label == "Caselist" then {
		next_caselist := caselist.children[1]
		grab_cases(next_caselist)
		casetype := caselist.children[3].children[1].tok

		#confirm every type is the same as t
		if casetype ~= basetype then {
			t := 10000 #number not equivalent to a token macro, ensures that all recursive calls fail
		 	fail
		}

		put(casevalues, caselist.children[3].children[1].s)

		} else if caselist.label == "cclause1" then { # last element
			put(casevalues, caselist.children[1].s)
	}

	# returns an empty list if the cases are not all the same type
	return casevalues
end



procedure caseexpr(root)
	write("\n------------------------------------")
	write("current frame :\n")

	node := root
	cases := []
	intlist := []

	if /node then {write("node type: null") ; fail}

	case type(node) of{
		# internal node
		"treenode" : {
			if node.label == "Case" then {
				write("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&")
				write("CASE EXPRESSION FOUND")
				caselist :=  node.children[5] # get caselist
				cexpr := node.children[2]
				write(cexpr.children[1].s)
				cases := grab_cases(caselist)

				#
				#	For now, only works with integer cases and not string cases
				#	

				cases := sort(cases) # sort the cases
				len := *cases

				# range of cases is cases[1]-cases[len]

				every 1 to cases[len] do put(intlist, 0)
				every i := 1 to len do intlist[cases[i]] := cases[i]



				write("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&")
			}
			printnode(node)
			every child := !node.children do caseexpr(child)
			
		}
	}

end



